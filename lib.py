import os
import pathlib
import subprocess
import time
import tempfile
from collections import defaultdict

import numpy as np
from PIL import Image

import grf
from grf import ZOOM_NORMAL, ZOOM_2X, ZOOM_4X, TEMPERATE, ARCTIC, TROPICAL, TOYLAND, ALL_CLIMATES


# VALUE_TO_BRIGHTNESS = np.array([0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 91, 91, 92, 93, 94, 95, 95, 96, 97, 98, 99, 100, 100, 101, 102, 103, 104, 105, 105, 106, 107, 108, 109, 109, 110, 111, 112, 113, 114, 114, 115, 116, 117, 118, 118, 119, 120, 121, 122, 123, 123, 124, 125, 126, 127, 127, 128, 129, 130, 131, 107, 108, 109, 109, 110, 111, 111, 112, 113, 113, 114, 115, 115, 116, 117, 117, 118, 119, 119, 120, 121, 121, 122, 123, 123, 124, 125, 125, 126, 127, 127, 128, 129, 130, 130, 131, 132, 132, 133, 134, 134, 135, 136, 136, 137, 138, 138, 139, 140, 140, 120, 120, 121, 121, 122, 122, 123, 124, 124, 125, 125, 126, 126, 127, 127, 128, 129, 129, 130, 130, 131, 131, 132, 133, 133, 134, 134, 135, 135, 136, 137, 137, 138, 138, 139, 139, 140, 141, 141, 142, 142, 143, 143, 144, 145, 146, 146, 147, 147, 148, 127, 128, 128, 128, 128, 130, 130, 131, 131, 132, 132, 133, 133, 134, 134, 135, 135, 136, 136, 137, 137, 138, 138, 139, 139, 140, 140, 141, 141, 142, 143, 143, 144, 144, 144, 145, 145, 146, 146, 147, 147, 148, 148, 149, 149, 150, 150, 151, 151, 152, 130, 131, 131, 132, 132, 133, 133, 134, 134, 135, 135, 136, 136, 137, 137, 138, 138, 139, 140, 140, 141, 141, 142, 142, 143, 143, 144, 144, 145, 145, 146, 146, 147, 147, 148, 148, 149, 150, 150, 151, 151, 152, 152, 153, 153, 154, 155, 155, 156, 156, 130, 130, 131, 131, 132, 132, 132, 133, 134, 134, 135, 135, 136, 136, 137, 137, 138, 139, 139, 140, 140, 141, 141, 142, 142, 143, 144, 144, 145, 145, 146, 146, 147, 147, 148, 149, 149, 150, 150, 151, 151, 152, 152, 153, 154, 154, 155, 156, 156, 157, 131, 132, 132, 133, 133, 134, 134, 135, 135, 136, 136, 137, 138, 138, 139, 139, 140, 140, 141, 141, 142, 143, 143, 144, 144, 145, 145, 146, 147, 147, 148, 149, 149, 150, 151, 151, 152, 152, 153, 154, 154, 155, 156, 156, 157, 157, 158, 159, 160, 160, 161, 162, 162, 163, 164, 165, 166, 166, 167, 168, 168, 169, 170, 171, 172, 173, 174, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 191, 192, 193, 194, 195, 197, 198, 199, 201, 203, 204, 206, 208, 210, 211, 214, 216, 218, 218])
# VALUE_TO_INDEX = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7])
# VALUE_TO_BRIGHTNESS = np.array([0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 55, 55, 57, 58, 59, 59, 61, 61, 63, 64, 64, 65, 67, 68, 69, 69, 70, 72, 72, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 96, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 125, 125, 126, 127, 128, 128, 130, 131, 132, 133, 134, 134, 136, 136, 136, 138, 138, 141, 117, 117, 119, 119, 119, 119, 122, 122, 123, 123, 124, 125, 125, 127, 127, 128, 128, 129, 130, 131, 131, 132, 133, 134, 134, 134, 136, 136, 137, 138, 138, 140, 117, 118, 118, 119, 119, 120, 121, 121, 122, 122, 123, 123, 124, 125, 125, 126, 127, 127, 128, 128, 129, 130, 130, 131, 131, 132, 132, 134, 134, 134, 135, 136, 136, 136, 137, 119, 119, 120, 120, 121, 122, 122, 123, 123, 124, 124, 125, 126, 126, 126, 127, 127, 128, 128, 129, 130, 130, 130, 131, 132, 132, 132, 133, 134, 134, 134, 136, 136, 136, 136, 137, 138, 121, 121, 121, 122, 122, 123, 123, 123, 123, 125, 125, 125, 125, 126, 126, 127, 127, 127, 128, 128, 128, 129, 130, 130, 131, 131, 131, 132, 132, 133, 133, 133, 134, 135, 135, 135, 135, 136, 136, 137, 138, 120, 120, 120, 121, 122, 122, 123, 123, 123, 123, 124, 124, 125, 125, 125, 126, 126, 127, 127, 127, 127, 128, 128, 128, 129, 129, 130, 130, 131, 131, 132, 132, 132, 133, 134, 134, 134, 134, 135, 135, 136, 136, 137, 138, 138, 138, 138, 139, 139, 121, 121, 121, 122, 122, 122, 122, 123, 123, 124, 124, 124, 124, 125, 125, 125, 126, 126, 126, 127, 127, 127, 127, 128, 128, 129, 129, 129, 130, 130, 131, 131, 131, 132, 132, 133, 133, 134, 134, 134, 135, 135, 135, 136, 137, 137, 137, 137, 137, 139, 139, 122, 123, 123, 123, 123, 124, 124, 124, 125, 125, 125, 126, 126, 126, 126, 127, 127, 127, 127, 128, 128, 128, 129, 129, 129, 130, 130, 131, 131, 131, 132, 132, 133, 133, 133, 133, 134, 135, 135, 135, 136, 137, 137, 137, 137, 138, 138, 139, 139, 141, 141, 141, 141, 141, 141, 141, 142, 143, 144, 144, 144, 145, 145, 149, 151, 152, 153, 153, 153, 155, 155, 155, 156, 158, 158, 159, 159, 159, 163, 163, 164, 164, 164, 166, 168, 168, 168, 168, 236, 236, 236, 245, 245, 249, 250, 252, 253, 254, 254, 215, 219, 238, 238, 242, 245, 248, 248, 248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])
# VALUE_TO_INDEX = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7])
# TODO VTB can't be 0
CC_VALUE_TO_BRIGHTNESS = np.array([0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 55, 55, 57, 58, 59, 59, 61, 61, 63, 64, 64, 65, 67, 68, 69, 69, 70, 72, 72, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 96, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 125, 125, 126, 127, 128, 128, 130, 131, 132, 133, 134, 134, 136, 136, 136, 138, 138, 141, 117, 117, 119, 119, 119, 119, 122, 122, 123, 123, 124, 125, 125, 127, 127, 128, 128, 129, 130, 131, 131, 132, 133, 134, 134, 134, 136, 136, 137, 138, 138, 140, 117, 118, 118, 119, 119, 120, 121, 121, 122, 122, 123, 123, 124, 125, 125, 126, 127, 127, 128, 128, 129, 130, 130, 131, 131, 132, 132, 134, 134, 134, 135, 136, 136, 136, 137, 119, 119, 120, 120, 121, 122, 122, 123, 123, 124, 124, 125, 126, 126, 126, 127, 127, 128, 128, 129, 130, 130, 130, 131, 132, 132, 132, 133, 134, 134, 134, 136, 136, 136, 136, 137, 138, 121, 121, 121, 122, 122, 123, 123, 123, 123, 125, 125, 125, 125, 126, 126, 127, 127, 127, 128, 128, 128, 129, 130, 130, 131, 131, 131, 132, 132, 133, 133, 133, 134, 135, 135, 135, 135, 136, 136, 137, 138, 120, 120, 120, 121, 122, 122, 123, 123, 123, 123, 124, 124, 125, 125, 125, 126, 126, 127, 127, 127, 127, 128, 128, 128, 129, 129, 130, 130, 131, 131, 132, 132, 132, 133, 134, 134, 134, 134, 135, 135, 136, 136, 137, 138, 138, 138, 138, 139, 139, 121, 121, 121, 122, 122, 122, 122, 123, 123, 124, 124, 124, 124, 125, 125, 125, 126, 126, 126, 127, 127, 127, 127, 128, 128, 129, 129, 129, 130, 130, 131, 131, 131, 132, 132, 133, 133, 134, 134, 134, 135, 135, 135, 136, 137, 137, 137, 137, 137, 139, 139, 122, 123, 123, 123, 123, 124, 124, 124, 125, 125, 125, 126, 126, 126, 126, 127, 127, 127, 127, 128, 128, 129, 129, 130, 130, 130, 130, 131, 131, 132, 132, 132, 132, 133, 133, 133, 133, 134, 134, 135, 135, 135, 135, 136, 136, 137, 137, 137, 137, 138, 138, 139, 139, 139, 139, 140, 140, 141, 141, 141, 141, 142, 142, 142, 142, 143, 143, 144, 144, 144, 144, 145, 145, 146, 146, 147, 147, 148, 148, 149, 149, 149, 149, 151, 151, 151, 151, 152, 152, 153, 153, 153, 153, 153, 153, 155, 155, 155, 155, 156, 156, 157, 157, 158, 158, 159, 159, 159, 159, 160, 160, 160, 160, 162, 162, 163, 163, 163, 163, 164, 164, 166, 166, 166, 166, 166])
CC_VALUE_TO_INDEX = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7])

STRUCT_VALUE_TO_BRIGHTNESS = np.array([0, 0, 0, 0, 0, 2, 2, 3, 3, 3, 5, 6, 10, 11, 15, 15, 19, 19, 23, 25, 31, 31, 35, 37, 42, 47, 47, 51, 57, 63, 63, 63, 69, 74, 79, 83, 87, 89, 95, 99, 105, 107, 111, 115, 120, 125, 128, 128, 128, 132, 132, 132, 132, 136, 136, 136, 136, 136, 136, 136, 140, 140, 140, 93, 95, 95, 98, 101, 101, 101, 106, 106, 108, 108, 108, 113, 115, 115, 117, 119, 120, 121, 124, 125, 127, 128, 128, 131, 132, 135, 136, 137, 137, 139, 142, 142, 144, 144, 147, 110, 111, 111, 113, 115, 115, 116, 118, 119, 121, 121, 123, 124, 124, 126, 127, 128, 128, 130, 130, 132, 133, 134, 136, 136, 136, 138, 140, 141, 141, 144, 144, 144, 110, 111, 112, 112, 113, 115, 115, 116, 118, 118, 119, 119, 120, 121, 122, 123, 124, 124, 125, 126, 127, 127, 128, 129, 130, 131, 131, 132, 133, 134, 134, 134, 136, 137, 137, 139, 139, 140, 117, 117, 119, 119, 119, 120, 121, 122, 122, 123, 123, 124, 124, 125, 126, 127, 127, 128, 128, 129, 130, 130, 131, 131, 132, 132, 133, 134, 134, 135, 135, 136, 137, 113, 113, 113, 115, 115, 115, 115, 117, 118, 118, 118, 118, 118, 120, 120, 120, 121, 122, 123, 123, 123, 123, 124, 125, 125, 126, 127, 127, 127, 128, 128, 129, 129, 130, 131, 131, 132, 132, 133, 134, 134, 134, 135, 135, 135, 137, 137, 120, 121, 122, 122, 122, 123, 123, 124, 124, 125, 125, 126, 126, 127, 127, 127, 128, 128, 129, 130, 130, 130, 131, 132, 132, 132, 132, 134, 134, 134, 134, 135, 136, 136, 121, 121, 121, 122, 122, 123, 123, 123, 124, 124, 125, 125, 126, 126, 126, 127, 127, 127, 128, 128, 129, 129, 129, 130, 130, 131, 132, 133, 133, 133, 134, 134, 134, 134, 135, 136, 136, 136, 136, 119, 119, 119, 119, 120, 120, 121, 121, 121, 121, 122, 122, 122, 123, 123, 123, 123, 124, 124, 124, 124, 124, 125, 125, 126, 126, 126, 126, 127, 127, 127, 127, 128, 128, 128, 129, 129, 129, 129, 130, 131, 131, 131, 132, 132, 132, 133, 134, 134, 134, 135, 135, 136, 136, 137, 137, 137, 139, 139, 139, 139, 123, 123, 123, 124, 124, 124, 125, 125, 125, 125, 126, 126, 126, 126, 127, 127, 127, 127, 128, 128, 128, 128, 129, 129, 129, 130, 130, 131, 131, 131, 132, 132, 133, 133, 134, 134, 134, 135, 135, 135, 135, 135, 136, 136, 136, 137, 137, 137, 139, 139, 139, 139, 144, 144, 144, 144, 146, 146, 146, 147, 149, 149, 152, 152, 152, 152, 152, 156, 158, 158, 159, 159, 160, 162, 162, 163, 163, 163, 169, 171, 181, 181, 183, 185, 185, 185, 187, 187, 189, 190, 191, 191, 191, 194, 196, 196, 198, 198, 198, 198, 201, 202, 204, 204, 205, 207, 210, 210, 210, 210, 212, 214, 216, 217, 217, 234, 236, 240, 240, 243, 243, 248, 248, 251, 253, 255, 255])
STRUCT_VALUE_TO_INDEX = np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9])

MAGENTA_TO_CC = (0, 0xC6, CC_VALUE_TO_BRIGHTNESS, CC_VALUE_TO_INDEX)
MAGENTA_TO_STRUCT = (1, 0x46, STRUCT_VALUE_TO_BRIGHTNESS, STRUCT_VALUE_TO_INDEX)
MAGENTA_TO_HOUSE_CC = (
    2, 0xC6,
    np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 7, 7, 7, 7, 9, 9, 11, 11, 12, 13, 14, 15, 15, 17, 17, 19, 19, 21, 21, 23, 24, 25, 26, 27, 29, 29, 31, 31, 31, 35, 35, 37, 37, 39, 39, 41, 41, 43, 44, 46, 47, 47, 49, 51, 51, 53, 54, 55, 57, 58, 59, 61, 63, 63, 63, 67, 67, 69, 69, 71, 73, 73, 75, 76, 78, 79, 81, 83, 83, 85, 85, 87, 89, 90, 91, 93, 95, 95, 97, 98, 99, 101, 103, 104, 105, 107, 108, 110, 111, 113, 114, 115, 117, 118, 119, 121, 123, 124, 126, 127, 128, 128, 130, 131, 132, 133, 134, 134, 136, 136, 136, 138, 138, 141, 117, 117, 118, 119, 119, 119, 122, 122, 123, 123, 124, 125, 125, 126, 127, 128, 128, 129, 130, 131, 131, 132, 132, 134, 134, 134, 136, 136, 137, 137, 138, 116, 117, 118, 118, 119, 119, 120, 121, 121, 122, 122, 123, 123, 124, 125, 125, 126, 127, 127, 128, 128, 129, 130, 130, 131, 131, 132, 132, 134, 134, 134, 135, 135, 136, 136, 137, 119, 119, 120, 120, 121, 122, 122, 123, 123, 124, 124, 125, 126, 126, 126, 127, 127, 128, 128, 129, 130, 130, 130, 132, 132, 132, 132, 133, 134, 134, 135, 136, 136, 136, 137, 137, 120, 121, 121, 121, 122, 122, 123, 123, 123, 123, 125, 125, 125, 125, 126, 126, 127, 127, 127, 128, 128, 128, 129, 130, 130, 131, 131, 131, 132, 132, 133, 133, 134, 134, 135, 135, 135, 135, 119, 119, 119, 120, 120, 120, 121, 121, 122, 122, 123, 123, 123, 123, 124, 124, 125, 125, 125, 126, 126, 127, 127, 127, 127, 128, 128, 128, 129, 129, 130, 131, 131, 132, 132, 133, 133, 133, 134, 134, 134, 135, 135, 136, 137, 137, 137, 119, 119, 120, 120, 121, 121, 121, 121, 122, 122, 122, 122, 122, 123, 124, 124, 124, 124, 125, 125, 125, 125, 126, 126, 127, 127, 127, 127, 127, 128, 128, 129, 129, 129, 130, 130, 131, 131, 131, 132, 132, 133, 133, 134, 134, 134, 135, 135, 135, 136, 137, 137, 137, 137, 137, 139, 122, 122, 123, 123, 123, 123, 124, 124, 124, 125, 125, 125, 126, 126, 126, 126, 127, 127, 127, 127, 128, 128, 128, 129, 129, 129, 130, 131, 131, 131, 131, 132, 132, 133, 133, 133, 134, 134, 135, 135, 135, 137, 137, 137, 137, 137, 138, 138, 139, 139, 141, 141, 141, 141, 141, 141, 141, 143, 144, 144, 144, 144, 145, 148, 149, 151, 152, 153, 153, 153, 155, 155, 156, 156, 158, 158, 159, 159, 159, 163, 163, 164, 164, 166, 166, 168, 168, 168, 236, 236, 236, 245, 245, 249, 250, 252, 253, 254, 254, 254, 254, 238, 238, 242, 245, 245, 248, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]),
    np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]),
)
MAGENTA_TO_SELECTION = (
    2, 0x0A,
    np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 12, 12, 10, 10, 13, 13, 14, 14, 15, 15, 14, 14, 16, 16, 17, 17, 18, 18, 19, 19, 19, 18, 18, 20, 20, 21, 21, 22, 19, 19, 23, 23, 24, 24, 25, 25, 23, 23, 26, 26, 27, 27, 28, 28, 26, 26, 29, 29, 30, 30, 31, 31, 29, 32, 32, 33, 33, 34, 34, 35, 35, 32, 32, 36, 36, 37, 38, 38, 35, 35, 39, 39, 40, 40, 41, 38, 38, 42, 42, 43, 43, 44, 44, 41, 45, 45, 46, 46, 47, 47, 40, 48, 48, 49, 49, 50, 50, 51, 47, 47, 52, 52, 53, 53, 54, 50, 50, 55, 55, 56, 56, 57, 48, 48, 58, 58, 59, 60, 60, 55, 55, 61, 62, 62, 63, 63, 58, 64, 64, 65, 65, 66, 67, 67, 49, 49, 68, 69, 69, 70, 70, 64, 71, 71, 72, 72, 73, 67, 67, 74, 74, 75, 76, 76, 70, 77, 77, 78, 78, 79, 73, 73, 80, 81, 81, 82, 82, 83, 76, 76, 84, 85, 85, 86, 86, 79, 87, 87, 88, 89, 89, 82, 82, 90, 91, 91, 92, 78, 78, 93, 94, 94, 95, 95, 87, 96, 96, 97, 98, 98, 99, 91, 91, 100, 101, 101, 102, 102, 86, 103, 103, 104, 105, 105, 96, 106, 106, 107, 108, 108, 99, 109, 109, 110, 111, 111, 102, 112, 112, 113, 114, 114, 115, 97, 97, 116, 117, 117, 118, 108, 108, 119, 120, 120, 121, 111, 111, 122, 123, 123, 124, 114, 114, 125, 126, 126, 127, 107, 107, 128, 128, 129, 129, 130, 130, 131, 131, 120, 120, 132, 132, 133, 133, 134, 134, 123, 123, 135, 135, 136, 136, 137, 137, 107, 107, 138, 138, 139, 139, 140, 140, 128, 128, 141, 141, 142, 142, 143, 143, 131, 131, 144, 144, 145, 145, 146, 146, 147, 147, 124, 124, 148, 148, 149, 149, 150, 150, 117, 117, 151, 151, 152, 152, 153, 153, 140, 140, 154, 154, 155, 155, 156, 156, 143, 143, 157, 157, 158, 158, 159, 159, 146, 146, 160, 160, 161, 161, 162, 162, 163, 163, 149, 149, 164, 164, 165, 165, 166, 166, 152, 152, 167, 167, 168, 168, 169, 169, 155, 155, 170, 170, 171, 171, 172, 172, 145, 145, 173, 173, 174, 174, 175, 175, 160, 160, 176, 176, 177, 177, 178, 178, 179, 179, 164, 164, 180, 180, 181, 181, 182, 182, 153, 153, 183, 183, 184, 184, 185, 185, 156, 156, 186, 186, 187, 187, 188, 188, 172, 172, 189, 189, 190, 190, 191, 191, 175, 175, 192, 192, 193, 193, 194, 194, 195]),
    np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]),
)

STRUCT_RECOLOURS = [  # Struct recolours
    [70, 71, 72, 73, 74, 75, 76, 77, 78, 79],  # no remap
    [144, 144, 145, 146, 147, 148, 149, 150, 151, 152],  # 795
    [104, 105, 106, 107, 108, 109, 110, 111, 37, 38],  # 796
    [70, 3, 5, 7, 8, 10, 11, 12, 13, 14],  # 797
    [70, 178, 179, 180, 181, 162, 163, 164, 165, 166],  # 798
    [70, 96, 96, 97, 98, 99, 100, 101, 102, 103],  # 799
    [70, 16, 17, 18, 19, 20, 21, 22, 23, 14],  # 800
    [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],  # 801
]

THIS_FILE = grf.PythonFile(__file__)

ASE_IDX = {}
def aseidx(path, **kw):
    key = (path, tuple(kw.items()))
    ase = ASE_IDX.get(key)
    if ase is None:
        ase = ASE_IDX[key] = AseImageFile(path, **kw)
    return ase


def zoom_to_factor(zoom):
    return {
        grf.ZOOM_NORMAL: 1,
        grf.ZOOM_2X: 2,
        grf.ZOOM_4X: 4,
    }[zoom]


# Takes a list of sprites or AlternativeSprites and shifts their xofs and yofs by provided values (multiplied by zoom factor)
def move(sprites, *, xofs, yofs):
    for s in sprites:
        if isinstance(s, grf.AlternativeSprites):
            sl = s.sprites
        else:
            sl = (s,)
        for s in sl:
            z = zoom_to_factor(s.zoom)
            s.xofs += xofs * z
            s.yofs += yofs * z
    return sprites


def template(sprite_class):
    def decorator(tmpl_func):
        def wrapper(name, paths, zoom, *args):
            def make_func_lists(path, zoom):
                if path is None:
                    return None
                try:
                    it = iter(path)
                except TypeError:
                    it = iter((path,))

                z = zoom_to_factor(zoom)
                def make_sprite_func(p):
                    if isinstance(p, (str, pathlib.Path)):
                        p = aseidx(p)
                    def sprite_func(suffix, *args, **kw):
                        return sprite_class(p, *args, **kw, zoom=zoom, name=name.format(suffix=suffix))
                    return sprite_func

                res = list(map(make_sprite_func, it))
                if len(res) == 1:
                    return res[0]
                return res

            funcs = make_func_lists(paths, zoom)
            return tmpl_func(funcs, zoom_to_factor(zoom), *args)

        return wrapper
    return decorator


class BaseGrid:
    def __init__(self, *, func, add_xofs=0, add_yofs=0, add_width=0, add_height=0):
        self.func = func
        self.add_xofs = add_xofs
        self.add_yofs = add_yofs
        self.add_width = add_width
        self.add_height = add_height
        self.kw = {}

    def set_default(self, **kw):
        self.kw.update(kw)
        return self

    def get_default(self, key):
        return self.kw.get(key)

    def __call__(self, name, x, y, *, width, height, keep_state=None, **kw):
        if self.add_xofs is not None:
            kw['xofs'] = self.add_xofs + kw.get('xofs', 0)
        if self.add_yofs is not None:
            kw['yofs'] = self.add_yofs + kw.get('yofs', 0)
        return self.func(name, x, y, width + self.add_width, height + self.add_height, **kw)


class RectGrid(BaseGrid):
    def __init__(self, *, func, width, height, padding=0, **kw):
        super().__init__(func=func, **kw)
        self.set_default(width=width, height=height)

        self.height = height
        self.width = width
        self.padding = padding

    def __call__(self, name, grid_pos, **kw):
        x, y = grid_pos
        fx = x * self.width + self.padding * (x + 1)
        fy = y * self.height + self.padding * (y + 1)
        kw = {**self.kw, **kw}
        return super().__call__(name, fx, fy, **kw)


class FlexGrid(BaseGrid):
    def __init__(self, *, func, padding=0, start=(0, 0), **kw):
        super().__init__(func=func, **kw)
        self.padding = padding
        self.x = padding + start[0]
        self.y = padding + start[1]

    def __call__(self, name, *, keep_state=False, **kw):
        kw = {**self.kw, **kw}

        x, y = self.x, self.y

        if not keep_state:
            self.x += kw['width'] + self.add_width + self.padding

        return super().__call__(name, x, y, **kw)


class HouseGrid(BaseGrid):
    def __init__(self, *, func, height, width=64, padding=2, z=2, offset=(0, 0), **kw):
        super().__init__(func=func, **kw)
        self.z = z

        # assert width == 64  # TODO width should participate in xofs if not 64
        self.zwidth = width * z
        self.zheight = height * z + z - 1

        self.zpadding = padding
        self.offset = offset

    def __call__(self, name, grid_pos, bb=None, rel=None, **kw):
        kw = {**self.kw, **kw}

        assert bb is None or rel is None
        x, y = grid_pos
        fx = x * self.zwidth + self.zpadding * (x + 1) + self.offset[0]
        fy = y * self.zheight + self.zpadding * (y + 1) + self.offset[1]
        if rel is not None:
            zxofs = -rel[0] * self.z
            zyofs = -rel[1] * self.z + 1
        else:
            zxofs = -31 * self.z
            # TODO buildings are aligned to bb so don't need z // 2 but maybe some stuff does
            # TODO x4 probably needs -1 zyofs
            zyofs = 31 * self.z - self.zheight # - self.z // 2  # z // 2 is a ground sprite offset to align foundations
            if bb is not None:
                zxofs -= self.z * (bb[1] - bb[0]) * 2
                zyofs -= self.z * (bb[0] + bb[1])
        return super().__call__(name, fx, fy, width=self.zwidth, height=self.zheight, xofs=zxofs, yofs=zyofs, **kw)

    def ground(self, name, grid_pos, **kw):
        x, y = grid_pos
        width = 64 * self.z
        height = 32 * self.z -1
        fx = x * self.zwidth + self.zpadding * (x + 1) + self.offset[0]
        fy = y * self.zheight + self.zpadding * (y + 1) + self.offset[1]
        zxofs = -31 * self.z
        zyofs = - self.z // 2  # ground sprite offset to align foundations
        kw = {**self.kw, **kw}
        return super().__call__(name, fx, fy + self.zheight - height, width=width, height=height, xofs=zxofs, yofs=zyofs, **kw)


class BuildingSlicesGrid(BaseGrid):
    def __init__(self, *, func, z=1, tile_size=(1, 1), xofs=0, yofs=0, offset=(0, 0), **kw):
        super().__init__(func=func, **kw)
        self.offset = offset
        self.tile_size = tile_size
        self.z = z
        self.xofs = xofs
        self.yofs = yofs

    def __call__(self, name, grid_pos, bb=None, **kw):
        gx, gy = grid_pos
        has_left = (gx == self.tile_size[0] - 1)
        has_right = (gy == self.tile_size[1] - 1)
        assert has_left or has_right

        tile_ws = 32 * self.z
        tile_hs = 16 * self.z
        x = -self.xofs - 31 * self.z + (gy - gx) * tile_ws
        y = -self.yofs + (gx + gy) * tile_hs
        MAX_HEIGHT = 200 * self.z  # above ground
        h = min(MAX_HEIGHT, y)
        xofs = kw.pop('xofs', None)
        yofs = kw.pop('yofs', None)
        kw = {**self.kw, **kw}
        return super().__call__(
            name,
            x + tile_ws * (not has_left) + self.offset[0],
            y - h + self.offset[1],
            width=tile_ws * (has_left + has_right),
            height=2 * tile_hs - 1 + h,
            xofs=(-31 * self.z if has_left else self.z) if xofs is None else xofs,
            yofs=(-h - (self.z // 2)) if yofs is None else yofs,
            **kw
        )


class BuildingSlicesGrid2(BaseGrid):
    class GroundGrid(BaseGrid):
        def __init__(self, building_grid):
            super().__init__(func=building_grid.func)
            self.building_grid = building_grid


        def __call__(self, name, grid_pos, **kw):
            sx, sy = self.building_grid.tile_size
            gx, gy = grid_pos
            z = self.building_grid.z
            assert gx < sx and gy < sy

            tile_ws = 32 * z
            tile_hs = 16 * z
            x = (gy - gx + sx - 1) * tile_ws  # left, relative to border
            ground_h = 32 * z - 1
            y = self.building_grid.zheight - ground_h - (sx + sy - 2 - gx - gy) * tile_hs  # top, relative to border

            kw = {**self.kw, **kw}
            return MaskGround(super().__call__(
                name,
                x + self.building_grid.offset[0] + self.building_grid.zborder,
                y + self.building_grid.offset[1] + self.building_grid.zborder,
                width=tile_ws * 2,
                height=ground_h,
                xofs=-31 * z,
                yofs=-(z // 2),  # ground sprite offset to align foundations
                **kw,
            ))


    def __init__(self, *, func, height, z=1, tile_size=(1, 1), offset=(0, 0), border=1, **kw):
        super().__init__(func=func, **kw)
        self.height = height
        self.z = z
        self.tile_size = tile_size
        self.offset = offset

        self.zheight = height * z + z - 1
        self.zborder = border * z
        self._ground_sprite = None
        self._ground_grid = None

    @property
    def ground(self):
        if self._ground_grid is None:
            self._ground_grid = self.GroundGrid(self)
        return self._ground_grid

    def __call__(self, name, grid_pos, *, has_left=None, has_right=None, below=0, **kw):
        sx, sy = self.tile_size
        gx, gy = grid_pos
        assert gx < sx and gy < sy
        if has_left is None:
            has_left = (gx == sx - 1)
        if has_right is None:
            has_right = (gy == sy - 1)
        assert has_left or has_right

        tile_ws = 32 * self.z
        tile_hs = 16 * self.z

        x = (gy - gx + self.tile_size[0] - 1) * tile_ws  # left, relative to border
        y = self.zheight - (sx + sy - 2 - gx - gy) * tile_hs  # bottom, relative to border
        MAX_HEIGHT = 200 * self.z  # above ground
        assert self.z < 4  # TODO yofs and h are off by one
        h = min(MAX_HEIGHT + 31 * self.z, y)
        xofs = kw.pop('xofs', None)
        yofs = kw.pop('yofs', None)
        kw = {**self.kw, **kw}
        return super().__call__(
            name,
            x + tile_ws * (not has_left) + self.offset[0] + self.zborder,
            y - h + self.offset[1] + self.zborder,
            width=tile_ws * (has_left + has_right),
            height=h + below,
            xofs=(-31 * self.z if has_left else self.z) if xofs is None else xofs,
            yofs=(-h + 31 * self.z) if yofs is None else yofs,
            **kw,
        )


old_sprites = defaultdict(dict)
new_sprites = defaultdict(lambda: defaultdict(dict))
old_sprites_collection = defaultdict(lambda: defaultdict(lambda: (10000, 0)))
new_sprites_collection = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: (10000, 0))))


dict_to_key = lambda d : tuple(sorted(d.items()))

def replace_old(collection, first_id, sprites, **kw):
    if isinstance(sprites, (grf.Resource, grf.ResourceAction)):
        sprites = [sprites]

    amount = len(sprites)
    assert first_id + amount <= 4896
    key = dict_to_key(kw)
    first, amount = old_sprites_collection[key][collection]
    old_sprites_collection[key][collection] = (min(first, first_id), amount + len(sprites))
    for i, s in enumerate(sprites):
        old_sprites[key][first_id + i] = s


def replace_new(collection, set_type, offset, sprites, **kw):
    if isinstance(sprites, (grf.Resource, grf.ResourceAction)):
        sprites = [sprites]
    key = dict_to_key(kw)
    first, amount = new_sprites_collection[key][set_type][collection]
    new_sprites_collection[key][set_type][collection] = (min(first, offset), amount + len(sprites))
    for i, s in enumerate(sprites):
        new_sprites[key][set_type][offset + i] = s


class SpriteCollection:
    def __init__(self, name):
        self.name = name
        self.sprites = []

    def __getitem__(self, sl):
        if isinstance(sl, int):
            sl = slice(sl, sl + 1)
        res = SpriteCollection(self.name)
        for zoom, kw, sprites in self.sprites:
            res.sprites.append((zoom, kw, sprites[sl]))
        return res

    def pick(self, *indexes):
        res = SpriteCollection(self.name)
        for zoom, kw, sprites in self.sprites:
            res.sprites.append((zoom, kw, [sprites[i] for i in indexes]))
        return res

    def __mul__(self, amount):
        assert isinstance(amount, int)
        res = SpriteCollection(self.name)
        for zoom, kw, sprites in self.sprites:
            res.sprites.append((zoom, kw, sprites * amount))
        return res

    def __len__(self):
        if len(self.sprites) == 0:
            return 0
        return len(self.sprites[0][2])

    def add(self, files, template, zoom,  *args, name=None, **kw):
        if not isinstance(files, tuple):
            files = (files,)
        files = tuple(aseidx(f) if isinstance(f, str) else f for f in files)
        z = zoom_to_factor(zoom)
        kwsuffix = ''
        name_str = '' if name is None else f'_{name}';
        if 'thin' in kw:
            kwsuffix = 'thin_' if kw['thin'] else 'thick_'
        sprites = template(f'{self.name}{name_str}_{{suffix}}_{kwsuffix}{z}x', files, zoom, *args)
        assert all(s.zoom  == zoom or s == grf.EMPTY_SPRITE for s in sprites)
        self.sprites.append((zoom, kw, sprites))
        return self

    def add_sprites(self, sprites, **kw):
        zoom = sprites[0].zoom
        self.sprites.append((zoom, kw, sprites))
        return self

    def compose_on(self, dest, pattern=None, exact_size=True, offsets=None):
        srckeys = set(tuple(p) for _, kw, _ in self.sprites for p in kw.items())
        dstkeys = set(tuple(p) for _, kw, _ in dest.sprites for p in kw.items())

        compose_keys = set()
        # print(self.name, dest.name)
        for srckeys in self.get_keys():
            for dstkeys in dest.get_keys():
                srckw = dict(srckeys)
                dstkw = dict(dstkeys)
                if any(k in dstkw and dstkw[k] != v for k, v in srckw.items()):
                    # have same key with different values -> incompatible
                    continue
                compose_keys.add(dict_to_key({**dstkw, **srckw}))
        #         print('    ', srckw, dstkw)
        # print()

        res = SpriteCollection(f'{dest.name}+{self.name}')

        def patternzip(dstl, srcl):
            if pattern is None:
                if len(dstl) == 1:
                    l = zip(srcl, [dstl[0]] * len(srcl))
                elif len(srcl) == 1:
                    l = zip([srcl[0]] * len(dstl), dstl)
                else:
                    assert len(dstl) == len(srcl)
                    l = zip(srcl, dstl)
            else:
                l = ((None if i is None else srcl[i], None if j is None else dstl[j]) for i, j in pattern)

            res = []
            for i, (s, d) in enumerate(l):
                if d is None:
                    res.append(s)
                    continue
                if s is None:
                    res.append(d)
                    continue
                offset = None if offsets is None else offsets[i]
                res.append(CompositeSprite((d, s), exact_size=exact_size, offset=offset))
            return res

            return [s if d is None else CompositeSprite((d, s), exact_size=exact_size) for s, d in l]

        # TODO calculate key combinations for each sprite separately to avoid bloating
        for keys in compose_keys:
            srcl = self.get_sprites(keys)
            dstl = dest.get_sprites(keys)
            # print(keys)
            # for s in self.sprites:
            #     print('SRC', s)
            # for s in dest.sprites:
            #     print('DST', s)
            assert srcl is not None and dstl is not None
            src1x, src2x = srcl
            dst1x, dst2x = dstl
            if src1x is not None and dst1x is not None:
                res.sprites.append((ZOOM_NORMAL, dict(keys), patternzip(dst1x, src1x)))
            if src2x is not None and dst2x is not None:
                res.sprites.append((ZOOM_2X, dict(keys), patternzip(dst2x, src2x)))
        return res

    def get_keys(self):
        keys1x = set(dict_to_key(kw) for zoom, kw, _ in self.sprites if zoom == ZOOM_NORMAL)
        keys2x = set(dict_to_key(kw) for zoom, kw, _ in self.sprites if zoom == ZOOM_2X)
        if len(keys2x) > len(keys1x):
            return keys2x
        return keys1x

    def _find_sprites(self, keys, exact):
        kw = dict(keys)
        d = {}
        for zoom, params, sprites in self.sprites:
            if any(k not in kw for k in params):
                continue
            if any(k in params and params[k] != v for k, v in kw.items()):
                continue
            matches = sum(k in params for k in kw)
            if zoom not in d or d[zoom][0] < matches:
                d[zoom] = (matches, sprites)

        # print(self.name, ', '.join(map(str, d.keys())), kw)
        # for zoom in (ZOOM_NORMAL, ZOOM_2X):
        #     if zoom in d:
        #         print('  ', zoom_to_factor(zoom), ', '.join(x.name for x in d[zoom][1]))
        # print()

        if exact and all(v[0] != len(kw) for v in d.values()):
            return None, None

        return d.get(ZOOM_NORMAL, (0, None))[1], d.get(ZOOM_2X, (0, None))[1]

    def get_sprites(self, keys):
        return self._find_sprites(keys, False)

    def get_exact_sprites(self, keys):
        x1, x2 = self._find_sprites(keys, True)
        if x2 is None and x1 is None:
            return None
        if x2 is None:
            return x1
        if x1 is None:
            return x2
        res = []
        for x1, x2 in zip(x1, x2):
            res.append(grf.AlternativeSprites(x1, x2))
        return res

    def _reduce(self, unspecify, **keys):
        if not keys:
            return self

        matches = {}
        for zoom, kw, sprites in self.sprites:

            # Find common keys
            match = []
            for k, v in kw.items():
                if k in keys:
                    if v != keys[k]:
                        continue  # Incompatible keys are filtered out
                    match.append(k)
            m = frozenset(match)

            if m in matches:
                matches[m].append((zoom, kw, sprites))
                continue

            # There is a better match already
            if any(m.issubset(mi) for mi in matches.keys()):
                continue

            # Delete worse matches
            for mi in list(matches.keys()):
                if mi.issubset(m):
                    del matches[mi]

            if unspecify:
                kw = {k: v for k, v in kw.items() if k not in keys}

            matches[m] = [(zoom, kw, sprites)]

        res = SpriteCollection(self.name)
        for sl in matches.values():
            res.sprites.extend(sl)
        return res

    def reduce(self, **keys):
        return self._reduce(False, **keys)

    def unspecify(self, **keys):
        return self._reduce(True, **keys)

    def replace_old(self, first_id, **kw):
        reduced = self.reduce(**kw)
        for key in reduced.get_keys():
            sprites = reduced.get_exact_sprites(key)
            cur_kw = kw.copy()
            for k, v in key:
                if k in cur_kw:
                    assert cur_kw[k] == v, (k, cur_kw[k], v)
                cur_kw[k] = v
            replace_old(self, first_id, sprites, **cur_kw)

    def replace_new(self, set_type, offset, **kw):
        reduced = self.reduce(**kw)
        for k in self.get_keys():
            sprites = reduced.get_exact_sprites(k)
            replace_new(self, set_type, offset, sprites, **dict(k), **kw)


class CCReplacingFileSprite(grf.FileSprite):
    def __init__(self, file, *args, **kw):
        super().__init__(file, *args, **kw)

    def get_data_layers(self, context, *args, **kw):
        w, h, img, bpp = self._do_get_image(context)

        timer = context.start_timer()

        if bpp != grf.BPP_32 and bpp != grf.BPP_24:
            raise RuntimeError('Only 32-bit RGB sprites are currently supported for CC replacement')

        self.bpp = bpp
        npimg = np.asarray(img).copy()

        magenta_mask = (
            (npimg[:, :, 0] == npimg[:, :, 2]) &
            (
                ((npimg[:, :, 0] == 255) & (npimg[:, :, 1] != 255)) |
                ((npimg[:, :, 1] == 0) & (npimg[:, :, 0] != 0))
            )
        )

        value = npimg[magenta_mask][:, 0].astype(np.uint16) + npimg[magenta_mask][:, 1]
        npimg[magenta_mask, 0] = CC_VALUE_TO_BRIGHTNESS[value]
        npimg[magenta_mask, 1] = 0
        npimg[magenta_mask, 2] = 0

        mask = np.zeros((h, w), dtype=np.uint8)
        mask[magenta_mask] = CC_VALUE_TO_INDEX[value] + 0xC6

        if bpp == grf.BPP_32:
            rgb, alpha = npimg[:, :, :3], npimg[:, :, 3]
        else:
            rgb, alpha = npimg, None

        timer.count_custom('Magenta and mask processing')

        return w, h, rgb, alpha, mask


    def get_resource_files(self):
        return super().get_resource_files() + (THIS_FILE,)


class SpriteWrapper(grf.Sprite):
    def __init__(self, sprites, *, name=None):
        self.sprites = sprites
        try:
            f = next(iter(self._iter_sprites()))
        except StopIteration:
            raise ValueError('SpriteWrapper got no sprites to wrap')

        super().__init__(w=f.w, h=f.h, xofs=f.xofs, yofs=f.yofs, zoom=f.zoom, bpp=f.bpp, crop=f.crop)

    def _iter_sprites(self):
        if isinstance(self.sprites, dict):
            i = self.sprites.values()
        else:
            i = self.sprites
        for s in i:
            if s is not None:
                yield s

    def get_image_files(self):
        return ()

    def get_resource_files(self):
        # TODO add wrapped class __file__, possibly traversing mro (do that globally?)
        res = super().get_resource_files() + (THIS_FILE,)
        for s in self._iter_sprites():
            res += s.get_resource_files()
        return res

    def get_fingerprint(self):
        res = {'class': self.__class__.__name__}
        if isinstance(self.sprites, dict):
            sf = {}
            for k, s in self.sprites.items():
                if s is None:
                    sf[k] = None
                else:
                    f = s.get_fingerprint()
                    if f is None:
                        return None
                    sf[k] = f
        else:
            sf = []
            for s in self.sprites:
                if s is None:
                    sf.append(None)
                    continue
                f = s.get_fingerprint()
                if f is None:
                    return None
                sf.append(f)
        res['sprites'] = sf
        return res

    def prepare_files(self):
        for s in self._iter_sprites():
            s.prepare_files()


class MaskGround(SpriteWrapper):
    def __init__(self, sprite):
        z = zoom_to_factor(sprite.zoom)
        assert sprite.w == 64 * z
        assert sprite.h == 32 * z - 1
        super().__init__((sprite, ))
        self.sprite = sprite

    def get_data_layers(self, context):
        z = zoom_to_factor(self.zoom)
        assert self.w == 64 * z
        assert self.h == 32 * z - 1
        w, h, rgb, alpha, mask = self.sprite.get_data_layers(context)
        assert w == 64 * z
        assert h == 32 * z - 1

        assert z == 2  # untested for other z
        tile_ws = 32 * z
        tile_hs = 16 * z

        ground_mask = np.full((h, w), True)

        def get_n (i, above):
            # i -= self.above_h - above
            n = i if i < tile_hs + above else 31 * z - i + above
            return max(0, min((n + 1) * 2, tile_ws))

        for i in range(h):
            nl = get_n(i, 0)
            nr = get_n(i, 0)
            ground_mask[i, tile_ws - nl: tile_ws + nr] = False
        if rgb is not None:
            rgb = grf.np_make_writable(rgb)
            rgb[ground_mask, :] = 0
        if alpha is not None:
            alpha = grf.np_make_writable(alpha)
            alpha[ground_mask] = 0
        if mask is not None:
            mask = grf.np_make_writable(mask)
            mask[ground_mask] = 0

        return w, h, rgb, alpha, mask


class MoveSprite(SpriteWrapper):
    def __init__(self, sprite, *, xofs=0, yofs=0):
        super().__init__((sprite, ))
        self.sprite = sprite
        self.xofs += xofs
        self.yofs += yofs

    def get_data_layers(self, context):
        return self.sprite.get_data_layers(context)

    def get_fingerprint(self):
        return grf.combine_fingerprint(
            super().get_fingerprint(),
            xofs=self.xofs,
            yofs=self.yofs,
        )


class DebugSprite(SpriteWrapper):
    def __init__(self, filename, sprite):
        super().__init__((sprite, ))
        self.filename = filename
        self.sprite = sprite

    def get_data_layers(self, context):
        w, h, rgb, alpha, mask = self.sprite.get_data_layers(context)
        if rgb is not None or alhpa is not None:
            rgba = np.zeros((h, w, 4), dtype=np.uint8)
            if rgb is not None:
                rgba[:, :, :3] = rgb
            if alpha is not None:
                rgba[:, :, 3] = alpha
            path = self.filename + '_rgba.png'
            Image.fromarray(rgba, mode='RGBA').save(path)
            print(f'Saved {path} for {self.sprite.name}')

        if mask is not None:
            im = Image.fromarray(mask, mode='P')
            im.putpalette(grf.PIL_PALETTE)
            path = self.filename + '_mask.png'
            im.save(path)
            print(f'Saved {path} for {self.sprite.name}')

        return w, h, rgb, alpha, mask

    def get_fingerprint(self):
        return grf.combine_fingerprint(
            super().get_fingerprint(),
            filename=self.filename
        )


def make_magenta_mask(rgb):
    return (
        (rgb[:, :, 0] == rgb[:, :, 2]) &
        (
            ((rgb[:, :, 0] == 255) & (rgb[:, :, 1] != 255)) |
            ((rgb[:, :, 1] == 0) & (rgb[:, :, 0] != 0))
        )
    )


class MagentaToColour(SpriteWrapper):
    def __init__(self, sprite, colour):
        self.colour = colour
        self._oklab_colour = grf.srgb_to_oklab(colour)
        super().__init__((sprite, ))

    def get_data_layers(self, context):
        w, h, rgb, alpha, mask = self.sprites[0].get_data_layers(context)

        timer = context.start_timer()

        magenta_mask = make_magenta_mask(rgb)
        value = rgb[magenta_mask][:, 0].astype(np.uint16) + rgb[magenta_mask][:, 1]
        value_map = np.zeros((255 * 2, 3), dtype=np.uint8)
        BLACK = grf.srgb_to_oklab((0, 0, 0))
        WHITE = grf.srgb_to_oklab((255, 255, 255))
        for v in set(value):
            if v < 255:
                value_map[v] = grf.oklab_to_srgb(grf.oklab_blend(BLACK, self._oklab_colour, v / 255.))
            elif v > 255:
                value_map[v] = grf.oklab_to_srgb(grf.oklab_blend(self._oklab_colour, WHITE, (v - 255) / 255.))
            else:
                value_map[v] = self.colour
        rgb = grf.np_make_writable(rgb)
        rgb[magenta_mask, :] = value_map[value]

        timer.count_custom('Magenta and mask processing')

        return w, h, rgb, alpha, mask

    def get_fingerprint(self):
        return grf.combine_fingerprint(
            super().get_fingerprint(),
            colour=self.colour,
        )


class MagentaRecolour(SpriteWrapper):
    def __init__(self, sprite, magenta_map):
        self.magenta_map = magenta_map
        super().__init__((sprite, ))

    def get_data_layers(self, context):
        _fingerprint, first, vtb, vti = self.magenta_map
        w, h, rgb, alpha, mask = self.sprites[0].get_data_layers(context)

        timer = context.start_timer()

        rgb = grf.np_make_writable(rgb)
        magenta_mask = make_magenta_mask(rgb)

        if mask is not None:
            magenta_mask &= (mask == 0)

        value = rgb[magenta_mask][:, 0].astype(np.uint16) + rgb[magenta_mask][:, 1]
        rgb[magenta_mask, 0] = vtb[value]
        rgb[magenta_mask, 1] = 0
        rgb[magenta_mask, 2] = 0

        if mask is None:
            mask = np.zeros((h, w), dtype=np.uint8)
        else:
            mask = grf.np_make_writable(mask)

        mask[magenta_mask] = vti[value] + first

        timer.count_custom('Magenta and mask processing')

        return w, h, rgb, alpha, mask

    def get_fingerprint(self):
        return grf.combine_fingerprint(
            super().get_fingerprint(),
            map=self.magenta_map[0],
        )


class MagentaToCC(MagentaRecolour):
    def __init__(self, sprite):
        super().__init__(sprite, MAGENTA_TO_CC)

class MagentaToHCC(MagentaRecolour):
    def __init__(self, sprite):
        super().__init__(sprite, MAGENTA_TO_HOUSE_CC)

class MagentaToStruct(MagentaRecolour):
    def __init__(self, sprite):
        super().__init__(sprite, MAGENTA_TO_STRUCT)

class MagentaToSelection(MagentaRecolour):
    def __init__(self, sprite):
        super().__init__(sprite, MAGENTA_TO_SELECTION)


class MagentaToLight(grf.Sprite):
    def __init__(self, sprite, order):
        self.sprite = sprite
        self.order = order
        super().__init__(w=sprite.w, h=sprite.h, xofs=sprite.xofs, yofs=sprite.yofs, zoom=sprite.zoom, bpp=sprite.bpp, name=self.sprite.name)

    def prepare_files(self):
        self.sprite.prepare_files()
        self.order.prepare_files()

    def get_data_layers(self, context):
        w, h, npimg, npalpha, npmask = self.sprite.get_data_layers(context)

        assert npmask is None
        ow, oh, ni, na, nm = self.order.get_data_layers(context)
        assert nm is None
        assert w == ow and h == oh

        timer = context.start_timer()

        magenta_mask = make_magenta_mask(rgb)

        order_mask = (na > 0)
        colours = list(set(map(tuple, ni[order_mask])))
        if len(colours) != 4:
            raise ValueError(f'Expected 4 colors in order mask, found {len(colours)} in {self.order.name}')
        colours.sort(key=lambda x: int(x[0]) + x[1] + x[2], reverse=True)

        order_mask &= magenta_mask
        order = ni[order_mask]
        if np.any(magenta_mask != order_mask):
            raise ValueError(f'Not all magenta pixels of sprite {self.sprite.name} have a defined order in {self.order.name}')

        npmask = np.zeros((h, w), dtype=np.uint8)
        ordered = np.zeros(order.shape[0], dtype=np.uint8)
        for i, c in enumerate(colours):
            ordered[(order == c).all(axis=1)] = 0xf1 + i
        npmask[order_mask] = ordered

        timer.count_custom('Magenta and mask processing')

        return w, h, npimg, npalpha, npmask

    def get_image_files(self):
        return ()

    def get_resource_files(self):
        return super().get_resource_files() + (THIS_FILE,) + self.sprite.get_resource_files() + self.order.get_resource_files()

    def get_fingerprint(self):
        return {
            'class': self.__class__.__name__,
            'sprite': self.sprite.get_fingerprint(),
            'order': self.order.get_fingerprint(),
        }


class MagentaAndMask(grf.Sprite):
    def __init__(self, sprite, mask, name=None):
        self.sprite = sprite
        super().__init__(w=sprite.w, h=sprite.h, xofs=sprite.xofs, yofs=sprite.yofs, zoom=sprite.zoom, bpp=sprite.bpp, name=name or self.sprite.name)
        self.mask = mask  # TODO sprite mask has a special meaning

    def prepare_files(self):
        self.sprite.prepare_files()
        self.mask.prepare_files()

    def get_data_layers(self, context):
        w, h, rgb, alpha, mask = self.sprite.get_data_layers(context)
        ow, oh, ni, na, nm = self.mask.get_data_layers(context)
        assert nm is None
        assert w == ow and h == oh

        timer = context.start_timer()

        magenta_mask = make_magenta_mask(rgb)

        anim_mask = (na > 0)
        pal_mask = (na > 0) & magenta_mask
        if np.any(anim_mask != pal_mask):
            context.warning('animated-missing-magenta', self, f'Not all pixels of animation sprite {self.mask.name} have a magenta in {self.sprite.name}')

        masked = ni[pal_mask]
        colours = set(map(tuple, masked))
        new_masked = np.zeros(masked.shape[0], dtype=np.uint8)

        for c in colours:
            m = grf.PALETTE_IDX.get(c)
            if m is None:
                raise ValueError(f'Color {c} is not in the palette in sprite {self.mask.name}')
            new_masked[(masked == c).all(axis=1)] = m

        mask = np.zeros((h, w), dtype=np.uint8) if mask is None else grf.np_make_writable(mask)
        mask[pal_mask] = new_masked
        brightness = (rgb[pal_mask,:2].sum(axis=1, dtype=np.uint16) + 1) // 2
        rgb = grf.np_make_writable(rgb)
        rgb[pal_mask, 0] = brightness
        rgb[pal_mask, 1] = 0
        rgb[pal_mask, 2] = 0

        timer.count_custom('Magenta and mask processing')

        return w, h, rgb, alpha, mask


    def get_image_files(self):
        return ()


    def get_resource_files(self):
        return super().get_resource_files() + (THIS_FILE,) + self.sprite.get_resource_files() + self.mask.get_resource_files()


    def get_fingerprint(self):
        return {
            'class': self.__class__.__name__,
            'sprite': self.sprite.get_fingerprint(),
            'mask': self.mask.get_fingerprint(),
        }


class AlphaAndMask(grf.Sprite):
    def __init__(self, sprite, mask, name=None):
        self.sprite = sprite
        super().__init__(w=sprite.w, h=sprite.h, xofs=sprite.xofs, yofs=sprite.yofs, zoom=sprite.zoom, bpp=sprite.bpp, name=name or self.sprite.name)
        self.mask = mask  # TODO sprite mask has a special meaning

    def prepare_files(self):
        self.sprite.prepare_files()
        self.mask.prepare_files()

    def get_data_layers(self, context):
        w, h, npimg, npalpha, npmask = self.sprite.get_data_layers(context)
        ow, oh, ni, na, nm = self.mask.get_data_layers(context)
        assert nm is None
        assert w == ow and h == oh

        timer = context.start_timer()

        mask = (na > 0)

        masked = ni[mask]
        colours = set(map(tuple, masked))
        new_masked = np.zeros(masked.shape[0], dtype=np.uint8)

        for c in colours:
            m = grf.PALETTE_IDX.get(c)
            if m is None:
                raise ValueError(f'Color {c} is not in the palette in sprite {self.mask.name}')
            new_masked[(masked == c).all(axis=1)] = m

        if npmask is None:
            npmask = np.zeros((h, w), dtype=np.uint8)
        else:
            npmask = grf.np_make_writable(npmask)
        npmask[mask] = new_masked
        npalpha = grf.np_make_writable(npalpha)
        npalpha[mask] = 255

        timer.count_custom('Alpha and mask processing')

        return w, h, npimg, npalpha, npmask


    def get_image_files(self):
        return ()


    def get_resource_files(self):
        return super().get_resource_files() + (THIS_FILE,) + self.sprite.get_resource_files() + self.mask.get_resource_files()


    def get_fingerprint(self):
        return {
            'class': self.__class__.__name__,
            'sprite': self.sprite.get_fingerprint(),
            'mask': self.mask.get_fingerprint(),
        }


# TODO switch anchor tile from bottom to top
class CutGround(grf.Sprite):
    def __init__(self, sprite, position, name=None, above=0):
        assert sprite.zoom == ZOOM_2X
        z = 2
        self.sprite = sprite
        self.position = position
        if isinstance(above, (tuple, list)):
            self.above_l, self.above_r = above
        else:
            self.above_l = self.above_r = above
        self.ground_h = 32 * z - 1
        self.above_h = max(self.above_l, self.above_r) * z
        super().__init__(w=64 * z, h=self.ground_h + self.above_h, xofs=-31 * z, yofs=-self.above_h - (z // 2), zoom=sprite.zoom, bpp=sprite.bpp, name=name)

    def prepare_files(self):
        self.sprite.prepare_files()

    def get_data_layers(self, context):
        gx, gy = self.position
        z = 2  # NOTE untested for other z
        tile_ws = 32 * z
        tile_hs = 16 * z
        x = -self.sprite.xofs - 31 * z + (gy - gx) * tile_ws
        y = -self.sprite.yofs + (gx + gy) * tile_hs - self.above_h


        w, h, rgb, alpha, mask = self.sprite.get_data_layers(context)
        ground_mask = np.full((self.h, self.w), True)

        def get_n (i, above):
            i -= self.above_h - above
            n = i if i < tile_hs + above else 31 * z - i + above
            return max(0, min((n + 1) * 2, tile_ws))

        for i in range(self.h):
            nl = get_n(i, self.above_l * z)
            nr = get_n(i, self.above_r * z)
            ground_mask[i, tile_ws - nl: tile_ws + nr] = False

        if x < 0 or y < 0 or y + self.h > h or x + self.w > w:
            raise ValueError(f'Ground sprite region({x}..{x + self.w}, {y}..{y + self.h}) is outside sprite boundaries (0..{w}, 0..{h}) for sprite {self.sprite.name}/{self.name}')

        if rgb is not None:
            rgb = rgb[y:y + self.h, x:x + self.w].copy()
            rgb[ground_mask, :] = 0
        if alpha is not None:
            alpha = alpha[y:y + self.h, x:x + self.w].copy()
            alpha[ground_mask] = 0
        if mask is not None:
            mask = mask[y:y + self.h, x:x + self.w].copy()
            mask[ground_mask] = 0

        return self.w, self.h, rgb, alpha, mask


    def get_image_files(self):
        return ()

    def get_resource_files(self):
        return super().get_resource_files() + (THIS_FILE,) + self.sprite.get_resource_files()

    def get_fingerprint(self):
        return {
            'class': self.__class__.__name__,
            'position': self.position,
            'xofs': self.xofs,
            'yofs': self.yofs,
            'sprite': self.sprite.get_fingerprint(),
            'above': (self.above_l, self.above_r),
        }


class AseImageFile(grf.ImageFile):
    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        self._images = None
        self._kw_requested = set()

    @staticmethod
    def _make_kw_key(frame=1, layers=None, ignore_layers=None):
        assert layers is None or ignore_layers is None, (layers, ignore_layers)
        if isinstance(layers, str):
            layers = (layers,)
        if isinstance(ignore_layers, str):
            ignore_layers = (ignore_layers,)
        return (frame, tuple(layers or ()), tuple(ignore_layers or ()))

    def prepare(self, **kw):
        self._kw_requested.add(self._make_kw_key(**kw))

    def _load_frame(self, fname):
        img = Image.open(fname)
        if img.mode == 'P':
            return (img, grf.BPP_8)
        elif img.mode == 'RGB':
            return (img, grf.BPP_24)
        if img.mode != 'RGBA':
            img = img.convert('RGBA')
        return (img, grf.BPP_32)

    def load(self):
        if self._images is not None:
            return

        aseprite_executible = os.environ.get('ASEPRITE_EXECUTABLE', 'aseprite')
        self._images = {}
        for kw in self._kw_requested:
            frame, layers, ignore_layers = kw
            with tempfile.NamedTemporaryFile(suffix='.png', delete=True) as f:
                args = [aseprite_executible, '-b', str(self.path), '--color-mode', 'rgb']
                for l in layers:
                    args.extend(('--layer', l))
                for l in ignore_layers:
                    args.extend(('--ignore-layer', l))
                args.extend(('--frame-range', f'{frame - 1},{frame - 1}'))
                args.extend(['--save-as', f.name])
                res = subprocess.run(args)
                args_str = ' '.join(res.args)
                if res.returncode != 0:
                    raise RuntimeError(f'Aseprite returned non-zero code {res.returncode}, command line: {args_str}')
                if not os.path.exists(f.name):
                    raise RuntimeError(f'Aseprite didn''t create an output file {f.name}, command line: {args_str}')
                try:
                    self._images[kw] = self._load_frame(f.name)
                except OSError as e:
                    raise RuntimeError(f'Error loading aseprite output file {f.name}, command line: {args_str}')

    def unload(self):
        for im in self._images.values():
            im[0].close()
        self._images = None

    def get_image(self, **kw):
        self.load()
        key = self._make_kw_key(**kw)
        return self._images[key]


class CompositeSprite(grf.Sprite):
    def __init__(self, sprites, *, exact_size=True, offset=None, **kw):
        if len(sprites) == 0:
            raise ValueError('CompositeSprite requires a non-empty list of sprites to compose')
        if len(set(s.zoom for s in sprites)) > 1:
            sprite_list = ', '.join(f'{s.name}<zoom={s.zoom}>' for s in sprites)
            raise ValueError(f'CompositeSprite requires a list of sprites of same zoom level: {sprite_list}')
        self.sprites = sprites
        self.exact_size = exact_size
        self.offset = offset
        super().__init__(sprites[0].w, sprites[0].h, xofs=sprites[0].xofs, yofs=sprites[0].yofs, zoom=sprites[0].zoom, **kw)

    def prepare_files(self):
        for s in self.sprites:
            s.prepare_files()

    def get_data_layers(self, context):
        npimg = None
        npalpha = None
        npmask = None
        nw, nh = self.w, self.h
        first = True
        for s in self.sprites:
            w, h, ni, na, nm = s.get_data_layers(context)
            timer = context.start_timer()

            if nw is None:
                nw = w
            if nh is None:
                nh = h
            if self.exact_size and (nw != w or nh != h):
                raise RuntimeError(f'CompositeSprite layers have different size: {self.sprites[0].name}({nw}, {nh}) vs {s.name}({w}, {h})')

            ox, oy = (0, 0) if self.offset is None or first else self.offset
            first = False

            dst_x, dst_y = max(ox, 0), max(oy, 0)
            src_x, src_y = -min(0, ox), -min(0, oy)
            src_my, src_mx = min(h, max(nh - dst_y + src_y, 0)), min(w, max(nw - dst_x + src_x, 0))

            dst = np.s_[dst_y:dst_y + src_my - src_y, dst_x: dst_x + src_mx - src_x]
            src = np.s_[src_y:src_my, src_x:src_mx]
            cur_rgb = None if ni is None else ni[src]
            cur_alpha = None if na is None else na[src]
            cur_mask = None if nm is None else nm[src]

            if cur_rgb is not None:
                if npimg is None or cur_alpha is None:
                    assert w == nw and h == nh  # TODO
                    npimg = cur_rgb.copy()
                    if cur_alpha is not None:
                        npalpha = cur_alpha.copy()
                    else:
                        npalpha = None
                else:
                    full_mask = (cur_alpha == 255)
                    partial_mask = (cur_alpha > 0) & ~full_mask

                    npimg[dst][full_mask] = cur_rgb[full_mask]
                    if npalpha is not None:
                        npalpha[dst][full_mask] = 255

                    if npalpha is None:
                        npalpha_norm_mask = np.full(partial_mask.sum(), 1.0)
                    else:
                        npalpha_norm_mask = npalpha[dst][partial_mask] / 255.0

                    na_norm_mask = cur_alpha[partial_mask] / 255.0
                    resa = npalpha_norm_mask + na_norm_mask * (1 - npalpha_norm_mask)

                    # TODO compose in oklab ?
                    npimg[dst][partial_mask] = (
                        npimg[dst][partial_mask] * npalpha_norm_mask[..., np.newaxis] +
                        cur_rgb[partial_mask] * (na_norm_mask * (1.0 - npalpha_norm_mask))[..., np.newaxis]
                    ) / resa[..., np.newaxis]
                    if npalpha is not None:
                        npalpha[dst][partial_mask] = (resa * 255).astype(np.uint8)

            if cur_mask is not None:
                if npmask is None:
                    assert w == nw and h == nh  # TODO
                    npmask = cur_mask.copy()
                else:
                    mask = (cur_mask != 0)
                    npmask[dst][mask] = cur_mask[mask]

            timer.count_custom('Layering')
        return nw, nh, npimg, npalpha, npmask

    def get_resource_files(self):
        res = [THIS_FILE]
        for s in self.sprites:
            res.extend(s.get_resource_files())
        return tuple(res)

    def get_fingerprint(self):
        return {
            'class': self.__class__.__name__,
            'sprites': [s.get_fingerprint() for s in self.sprites],
            'offset': self.offset,
        }


def adjust_brightness(c, brightness):
    if brightness == 128:
        return c

    r, g, b = c
    combined = (r << 32) | (g << 16) | b
    combined *= brightness

    r = (combined >> 39) & 0x1ff
    g = (combined >> 23) & 0x1ff
    b = (combined >> 7) & 0x1ff

    if (combined & 0x800080008000) == 0:
        return (r, g, b)

    ob = 0
    # Sum overbright
    if r > 255: ob += r - 255
    if g > 255: ob += g - 255
    if b > 255: ob += b - 255

    # Reduce overbright strength
    ob //= 2
    return (
        255 if r >= 255 else min(r + ob * (255 - r) // 256, 255),
        255 if g >= 255 else min(g + ob * (255 - g) // 256, 255),
        255 if b >= 255 else min(b + ob * (255 - b) // 256, 255),
    )


def debug_recolour(sprites, recolours, horizontal=False):
    PADDING = 10

    context = grf.WriteContext()
    slayers = []
    for i, s in enumerate(sprites):
        s.prepare_files()
    for i, s in enumerate(sprites):
        slayers.append(s.get_data_layers(context))

    pos = []
    if horizontal:
        maxw = max(x[0] for x in slayers)
        x = PADDING
        for i in range(len(recolours)):
            y = PADDING
            row = []
            for s in slayers:
                row.append(((x, y)))
                y += s[1] + PADDING
            pos.append(row)
            x += maxw + PADDING
    else:
        # s = (sumh + (len(slayers) + 1) * PADDING, maxw + 2 * PADDING)
        y = PADDING
        maxh = max(x[1] for x in slayers)
        for i in range(len(recolours)):
            x = PADDING
            row = []
            for s in slayers:
                row.append(((x, y)))
                x += s[0] + PADDING
            pos.append(row)
            y += maxh + PADDING

    npres = np.zeros((y, x, 4), dtype=np.uint8)
    for jj, s, (w, h, rgb, alpha, mask) in zip(range(len(sprites)), sprites, slayers):
        if mask is None:
            raise ValueError(f'Sprite {s.name} has no mask!')

        for ii, recolour in enumerate(recolours):
            x, y = pos[ii][jj]
            for i in range(h):
                for j in range(w):
                    mrgb = recolour.get(mask[i, j])
                    if mrgb is None:
                        npres[y + i, x + j, :3] = rgb[i, j, :]
                    else:
                        b = max(rgb[i, j])
                        npres[y + i, x + j, :3] = adjust_brightness(mrgb, b)
                    if alpha is not None:
                        npres[y + i, x + j, 3] = alpha[i, j]
                    else:
                        npres[y + i, x + j, 3] = 255

    im = Image.fromarray(npres, mode='RGBA')
    im.show()


def debug_cc_recolour(sprites, horizontal=False):
    recolours = []
    for cl in grf.CC_COLOURS:
        recolours.append({
            0xC6 + i : grf.PALETTE[m]
            for i, m in enumerate(cl)
        })
    debug_recolour(sprites, recolours, horizontal=horizontal)


def debug_struct_recolour(sprites, horizontal=False):
    recolours = []
    for cl in STRUCT_RECOLOURS:
        recolours.append({
            0x46 + i : grf.PALETTE[m]
            for i, m in enumerate(cl)
        })
    debug_recolour(sprites, recolours, horizontal=horizontal)


def debug_light_cycle(sprites, horizontal=False):
    ON = (240, 208, 0)
    OFF = (0, 0, 0)
    recolours = [
        {0xf1: OFF, 0xf2: OFF, 0xf3: OFF, 0xf4: ON},
        {0xf1: OFF, 0xf2: OFF, 0xf3: ON, 0xf4: OFF},
        {0xf1: OFF, 0xf2: ON, 0xf3: OFF, 0xf4: OFF},
        {0xf1: ON, 0xf2: OFF, 0xf3: OFF, 0xf4: OFF},
    ]
    debug_recolour(sprites, recolours, horizontal=horizontal)
